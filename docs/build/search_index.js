var documenterSearchIndex = {"docs":
[{"location":"#JlrsReflect.jl-Documentation","page":"JlrsReflect.jl Documentation","title":"JlrsReflect.jl Documentation","text":"","category":"section"},{"location":"","page":"JlrsReflect.jl Documentation","title":"JlrsReflect.jl Documentation","text":"One of the main features of jlrs is the possibility to easily convert data from Julia to Rust. By default only a few builtin types, like integers, arrays and modules are available, but this can be extended by using the JuliaStruct derive macro. One annoying aspect of this macro is that you need to figure out the correct layout first.","category":"page"},{"location":"","page":"JlrsReflect.jl Documentation","title":"JlrsReflect.jl Documentation","text":"With JlrsReflect.jl you can automatically generate the appropriate bindings for many Julia types if you're using Julia 1.5. This includes types with unions, tuples, and type parameters. Even value types are not a problem because the bindings only contain type parameters that directly affect the layout. If a field contains pointers, featureful wrappers from jlrs with reasonable lifetimes are used. Two things that are not supported are structs with union or tuple fields that depend on a type parameter (eg struct SomeGenericStruct{T} a::Tuple{Int32, T} end, SomeGenericStruct{T} a::Union{Int32, T} end), and unions used as generic parameters (eg SomeGenericStruct{Union{A,B}}).","category":"page"},{"location":"","page":"JlrsReflect.jl Documentation","title":"JlrsReflect.jl Documentation","text":"reflect\nrenamestruct!\nrenamefields!","category":"page"},{"location":"#JlrsReflect.reflect","page":"JlrsReflect.jl Documentation","title":"JlrsReflect.reflect","text":"reflect(types::Vector{<:Type})::Wrappers\n\nGenerate Rust wrappers for all types in types and their dependencies. The only requirement is that these types must not contain any union or tuple fields that depend on a type parameter. Wrappers are generated for the most general case by erasing the contents of all provided type parameters, so you can't avoid this restriction by explicitly providing a more qualified type. The only effect qualifying types has, is that wrappers for the used parameters will also be generated. The wrappers will derive Unbox and ValidLayout, and IntoJulia if it's a bits-type with no type parameters.\n\nThe result of this function can be written to a file, its contents will normally be a valid Rust module.\n\nWhen you use these wrappers with jlrs, these types must be available with the same path. For example, if you generate wrappers for Main.Bar.Baz, this type must be available through that exact path and not some other path like Main.Foo.Bar.Baz.\n\nExample\n\njulia> using JlrsReflect\n\njulia> reflect([StackTraces.StackFrame])\n#[repr(C)]\n#[derive(Clone, Debug, Unbox, ValidLayout, Typecheck)]\n#[jlrs(julia_type = \"Base.StackTraces.StackFrame\")]\npub struct StackFrame<'frame, 'data> {\n    pub func: ::jlrs::wrappers::ptr::SymbolRef<'frame>,\n    pub file: ::jlrs::wrappers::ptr::SymbolRef<'frame>,\n    pub line: i64,\n    pub linfo: ::jlrs::wrappers::ptr::ValueRef<'frame, 'data>,\n    pub from_c: ::jlrs::wrappers::inline::bool::Bool,\n    pub inlined: ::jlrs::wrappers::inline::bool::Bool,\n    pub pointer: u64,\n}\n\n#[repr(C)]\n#[derive(Clone, Debug, Unbox, ValidLayout, Typecheck)]\n#[jlrs(julia_type = \"Core.CodeInfo\")]\npub struct CodeInfo<'frame, 'data> {\n    pub code: ::jlrs::wrappers::ptr::ArrayRef<'frame, 'data>,\n    pub codelocs: ::jlrs::wrappers::ptr::ArrayRef<'frame, 'data>,\n    pub ssavaluetypes: ::jlrs::wrappers::ptr::ValueRef<'frame, 'data>,\n    pub ssaflags: ::jlrs::wrappers::ptr::ArrayRef<'frame, 'data>,\n    pub method_for_inference_limit_heuristics: ::jlrs::wrappers::ptr::ValueRef<'frame, 'data>,\n    pub linetable: ::jlrs::wrappers::ptr::ValueRef<'frame, 'data>,\n    pub slotnames: ::jlrs::wrappers::ptr::ArrayRef<'frame, 'data>,\n    pub slotflags: ::jlrs::wrappers::ptr::ArrayRef<'frame, 'data>,\n    pub slottypes: ::jlrs::wrappers::ptr::ValueRef<'frame, 'data>,\n    pub rettype: ::jlrs::wrappers::ptr::ValueRef<'frame, 'data>,\n    pub parent: ::jlrs::wrappers::ptr::ValueRef<'frame, 'data>,\n    pub edges: ::jlrs::wrappers::ptr::ValueRef<'frame, 'data>,\n    pub min_world: u64,\n    pub max_world: u64,\n    pub inferred: ::jlrs::wrappers::inline::bool::Bool,\n    pub inlineable: ::jlrs::wrappers::inline::bool::Bool,\n    pub propagate_inbounds: ::jlrs::wrappers::inline::bool::Bool,\n    pub pure: ::jlrs::wrappers::inline::bool::Bool,\n}\n\n#[repr(C)]\n#[derive(Clone, Debug, Unbox, ValidLayout, Typecheck, IntoJulia)]\n#[jlrs(julia_type = \"Core.Nothing\", zero_sized_type)]\npub struct Nothing {\n}\n\n\n\n\n\n","category":"function"},{"location":"#JlrsReflect.renamestruct!","page":"JlrsReflect.jl Documentation","title":"JlrsReflect.renamestruct!","text":"renamestruct!(wrappers::Wrappers, type::Type, rename::String)\n\nChange a struct's name. This can be useful if the name of a struct results in invalid Rust code or causes warnings.\n\nExample\n\njulia> using JlrsReflect\n\njulia> struct Foo end\n\njulia> wrappers = reflect([Foo]);\n\njulia> renamestruct!(wrappers, Foo, \"Bar\")\n\njulia> wrappers\n#[repr(C)]\n#[derive(Clone, Debug, Unbox, ValidLayout, Typecheck, IntoJulia)]\n#[jlrs(julia_type = \"Main.Foo\", zero_sized_type)]\npub struct Bar {\n}\n\n\n\n\n\n","category":"function"},{"location":"#JlrsReflect.renamefields!","page":"JlrsReflect.jl Documentation","title":"JlrsReflect.renamefields!","text":"renamefields!(wrappers::Wrappers, type::Type, rename::Dict{Symbol,String})\nrenamefields!(wrappers::Wrappers, type::Type, rename::Vector{Pair{Symbol,String})\n\nChange some field names of a struct. This can be useful if the name of a struct results in invalid Rust code or causes warnings.\n\nExample\n\njulia> using JlrsReflect\n\njulia> struct Food burger::Bool end\n\njulia> wrappers = reflect([Food]);\n\njulia> renamefields!(wrappers, Food, [:burger => \"hamburger\"])\n\njulia> wrappers\n#[repr(C)]\n#[derive(Clone, Debug, Unbox, ValidLayout, Typecheck, IntoJulia)]\n#[jlrs(julia_type = \"Main.Food\")]\npub struct Food {\n    pub hamburger: ::jlrs::wrappers::inline::bool::Bool,\n}\n\n\n\n\n\n\n","category":"function"}]
}
