var documenterSearchIndex = {"docs":
[{"location":"#JlrsReflect.jl-Documentation","page":"JlrsReflect.jl Documentation","title":"JlrsReflect.jl Documentation","text":"","category":"section"},{"location":"","page":"JlrsReflect.jl Documentation","title":"JlrsReflect.jl Documentation","text":"One of the main features of jlrs is the possibility to easily convert data from Julia to Rust. By default only a few builtin types, like integers, arrays and modules are available, but this can be extended by using the JuliaStruct derive macro. One annoying aspect of this macro is that you need to figure out the correct layout first.","category":"page"},{"location":"","page":"JlrsReflect.jl Documentation","title":"JlrsReflect.jl Documentation","text":"With JlrsReflect.jl you can automatically generate the appropriate bindings for many Julia types if you're using Julia 1.5. This includes types with unions, tuples, and type parameters. Even value types are not a problem because the bindings only contain type parameters that directly affect the layout. If a field contains pointers, featureful wrappers from jlrs with reasonable lifetimes are used. Two things that are not supported are structs with union or tuple fields that depend on a type parameter (eg struct SomeGenericStruct{T} a::Tuple{Int32, T} end, SomeGenericStruct{T} a::Union{Int32, T} end), and unions used as generic parameters (eg SomeGenericStruct{Union{A,B}}).","category":"page"},{"location":"","page":"JlrsReflect.jl Documentation","title":"JlrsReflect.jl Documentation","text":"reflect\nrenamestruct!\nrenamefields!","category":"page"},{"location":"#JlrsReflect.reflect","page":"JlrsReflect.jl Documentation","title":"JlrsReflect.reflect","text":"reflect(types::Vector{<:Type})::Bindings\n\nGenerate Rust mappings for all types in types and their dependencies. The only requirement is that these types must not contain any union or tuple fields that depend on a free type parameter. Bindings are generated for the most general case by erasing the contents of all provided parameters, so you can't avoid this restriction by explicitly trying to avoid this restriction by providing a more qualified type. The only effect qualifying types has, is that bindings to these types will also be generated. The mappings will derive JuliaStruct, and IntoJulia if it's a bits type (with no free type parameters).\n\nThe result of this method can be written to a file, its contents will normally be a valid Rust module.\n\nWhen you use these mappings with jlrs, these types must be available with the same path. For example, if you generate bindings for Main.Bar.Baz, this type must be available through that exact path and not some other path like Main.Foo.Bar.Baz.\n\nBits unions are turned into three fields for size and alignment requirement purposes. Besides a field with the same name that contains the raw data, a private field that enforces the proper alignment named _{fieldname}_align and a public field named {fieldname}_flag that contains the flag that indicates the active variant will be generated.\n\nExample\n\njulia> using JlrsReflect\n\njulia> reflect([StackTraces.StackFrame])\n#[repr(C)]\n#[jlrs(julia_type = \"Base.StackTraces.StackFrame\")]\n#[derive(Copy, Clone, Debug, JuliaStruct)]\npub struct StackFrame<'frame, 'data> {\n    pub func: ::jlrs::value::symbol::Symbol<'frame>,\n    pub file: ::jlrs::value::symbol::Symbol<'frame>,\n    pub line: i64,\n    pub linfo: ::jlrs::value::Value<'frame, 'data>,\n    pub from_c: bool,\n    pub inlined: bool,\n    pub pointer: u64,\n}\n\n#[repr(C)]\n#[jlrs(julia_type = \"Core.CodeInfo\")]\n#[derive(Copy, Clone, Debug, JuliaStruct)]\npub struct CodeInfo<'frame, 'data> {\n    pub code: ::jlrs::value::array::Array<'frame, 'data>,\n    pub codelocs: ::jlrs::value::Value<'frame, 'data>,\n    pub ssavaluetypes: ::jlrs::value::Value<'frame, 'data>,\n    pub ssaflags: ::jlrs::value::array::Array<'frame, 'data>,\n    pub method_for_inference_limit_heuristics: ::jlrs::value::Value<'frame, 'data>,\n    pub linetable: ::jlrs::value::Value<'frame, 'data>,\n    pub slotnames: ::jlrs::value::array::Array<'frame, 'data>,\n    pub slotflags: ::jlrs::value::array::Array<'frame, 'data>,\n    pub slottypes: ::jlrs::value::Value<'frame, 'data>,\n    pub rettype: ::jlrs::value::Value<'frame, 'data>,\n    pub parent: ::jlrs::value::Value<'frame, 'data>,\n    pub edges: ::jlrs::value::Value<'frame, 'data>,\n    pub min_world: u64,\n    pub max_world: u64,\n    pub inferred: bool,\n    pub inlineable: bool,\n    pub propagate_inbounds: bool,\n    pub pure: bool,\n}\n\n#[repr(C)]\n#[jlrs(julia_type = \"Core.Nothing\")]\n#[derive(Copy, Clone, Debug, JuliaStruct)]\npub struct Nothing {\n}\n\n\n\n\n\n","category":"function"},{"location":"#JlrsReflect.renamestruct!","page":"JlrsReflect.jl Documentation","title":"JlrsReflect.renamestruct!","text":"renamestruct!(bindings::Bindings, type::Type, rename::String)\n\nChange a struct's name. This can be useful if the name of a struct results in invalid Rust code or causes warnings.\n\nExample\n\njulia> using JlrsReflect\n\njulia> struct Foo end;\n\njulia> bindings = reflect([Foo]);\n\njulia> renamestruct!(bindings, Foo, \"Bar\")\n\njulia> bindings\n#[repr(C)]\n#[jlrs(julia_type = \"Main.Foo\")]\n#[derive(Copy, Clone, Debug, JuliaStruct)]\npub struct Bar {\n}\n\n\n\n\n\n","category":"function"},{"location":"#JlrsReflect.renamefields!","page":"JlrsReflect.jl Documentation","title":"JlrsReflect.renamefields!","text":"renamefields!(bindings::Bindings, type::Type, rename::Dict{Symbol,String})\nrenamefields!(bindings::Bindings, type::Type, rename::Vector{Pair{Symbol,String})\n\nChange some field names of a struct. This can be useful if the name of a struct results in invalid Rust code or causes warnings.\n\nExample\n\njulia> using JlrsReflect\n\njulia> struct Food\n    🍔::Bool\nend;\n\njulia> bindings = reflect([Food]);\n\njulia> renamefields!(bindings, Food, [:🍔 => \"burger\"])\n\njulia> bindings\n#[repr(C)]\n#[jlrs(julia_type = \"Main.Foo\")]\n#[derive(Copy, Clone, Debug, JuliaStruct)]\npub struct Food {\n    burger: bool\n}\n\n\n\n\n\n","category":"function"}]
}
