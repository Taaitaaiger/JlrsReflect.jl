var documenterSearchIndex = {"docs":
[{"location":"#JlrsReflect.jl-Documentation","page":"JlrsReflect.jl Documentation","title":"JlrsReflect.jl Documentation","text":"","category":"section"},{"location":"","page":"JlrsReflect.jl Documentation","title":"JlrsReflect.jl Documentation","text":"One of the features of jlrs, a crate that provides bindings to the Julia C API for the Rust programming language, is that it supports mapping a struct from Julia to a Rust struct which lets you access its contents directly. Writing down the correct implementation of these structs in Rust can be challenging, this package can be used to automate the process.","category":"page"},{"location":"","page":"JlrsReflect.jl Documentation","title":"JlrsReflect.jl Documentation","text":"Many types are supported, the major exceptions are types with tuple or union fields that depend on a free type parameter. These fields can have very different representations depending on these parameters which makes generating an appropriate mapping impossible. Everything else is fine, though; Types with bits union fields, UnionAll fields, type parameters, and \"special\" types backed by a struct defined in C like Module and Array are all supported.","category":"page"},{"location":"","page":"JlrsReflect.jl Documentation","title":"JlrsReflect.jl Documentation","text":"There is a single entrypoint, the reflect method which takes a Vector of Types. Mappings will be generated for all of these types and their dependencies. The result of a call to this method can be written to a .rs-file and used as a module without any tweaking. ","category":"page"},{"location":"","page":"JlrsReflect.jl Documentation","title":"JlrsReflect.jl Documentation","text":"This package is compatible with Julia v1.5 and jlrs v0.6.","category":"page"},{"location":"","page":"JlrsReflect.jl Documentation","title":"JlrsReflect.jl Documentation","text":"reflect","category":"page"},{"location":"#Main.JlrsReflect.reflect","page":"JlrsReflect.jl Documentation","title":"Main.JlrsReflect.reflect","text":"reflect(types::Vector{<:Type})::Bindings\n\nGenerate Rust mappings for all types in types and their dependencies. The only requirement is  that these types must not contain any union or tuple fields that depend on a free type parameter. The mappings will derive JuliaStruct, and IntoJulia if it's a bits type.\n\nThe result of this method can be written to a file, its contents will be a valid Rust module.\n\nWhen you use these mappings with jlrs, these types must be available with the same path. For  example, if you generate bindings for Main.Bar.Baz, they must be available on that path and not some other path like Main.Foo.Bar.Baz. \n\nExample\n\njulia> using JlrsReflect\n\njulia> reflect([StackTraces.StackFrame])\n#[repr(C)]\n#[jlrs(julia_type = \"Base.StackTraces.StackFrame\")]\n#[derive(Copy, Clone, Debug, JuliaStruct)]\npub struct StackFrame<'frame, 'data> {\n    pub func: ::jlrs::value::symbol::Symbol<'frame>,\n    pub file: ::jlrs::value::symbol::Symbol<'frame>,\n    pub line: i64,\n    pub linfo: ::jlrs::value::Value<'frame, 'data>,\n    pub from_c: bool,\n    pub inlined: bool,\n    pub pointer: u64,\n}\n\n#[repr(C)]\n#[jlrs(julia_type = \"Core.CodeInfo\")]\n#[derive(Copy, Clone, Debug, JuliaStruct)]\npub struct CodeInfo<'frame, 'data> {\n    pub code: ::jlrs::value::array::Array<'frame, 'data>,\n    pub codelocs: ::jlrs::value::Value<'frame, 'data>,\n    pub ssavaluetypes: ::jlrs::value::Value<'frame, 'data>,\n    pub ssaflags: ::jlrs::value::array::Array<'frame, 'data>,\n    pub method_for_inference_limit_heuristics: ::jlrs::value::Value<'frame, 'data>,\n    pub linetable: ::jlrs::value::Value<'frame, 'data>,\n    pub slotnames: ::jlrs::value::array::Array<'frame, 'data>,\n    pub slotflags: ::jlrs::value::array::Array<'frame, 'data>,\n    pub slottypes: ::jlrs::value::Value<'frame, 'data>,\n    pub rettype: ::jlrs::value::Value<'frame, 'data>,\n    pub parent: ::jlrs::value::Value<'frame, 'data>,\n    pub edges: ::jlrs::value::Value<'frame, 'data>,\n    pub min_world: u64,\n    pub max_world: u64,\n    pub inferred: bool,\n    pub inlineable: bool,\n    pub propagate_inbounds: bool,\n    pub pure: bool,\n}\n\n#[repr(C)]\n#[jlrs(julia_type = \"Core.Nothing\")]\n#[derive(Copy, Clone, Debug, JuliaStruct)]\npub struct Nothing {\n}\n\n\n\n\n\n","category":"function"}]
}
